import random
import json
from faker import Faker
from src import db
from src.tools.db_tools import clear_database, generate_unique_id
from sqlalchemy import text

fake = Faker("en_US")


def add_teacher(survey_id):
    db.session.execute(text("""
        INSERT INTO users (id, name, email, isteacher, admin, language)
        VALUES (999999999, 'opettaja', 'opettaja@mail.com', TRUE, FALSE, 'fi')
        ON CONFLICT (id) DO UPDATE SET name='Opettaja'
    """))

    db.session.execute(text("""
        INSERT INTO survey_owners (survey_id, user_id)
        VALUES (:survey_id, 999999999)
        ON CONFLICT DO NOTHING
    """), {"survey_id": survey_id})


def add_students(count):
    db.session.execute(text("DELETE FROM users WHERE id BETWEEN 1 AND :c"), {"c": count})

    for uid in range(1, count + 1):
        name = fake.name()

        base = (
            name.lower()
        )

        email = f"{base}.{uid}@test.com"

        db.session.execute(text("""
            INSERT INTO users (id, name, email, isteacher, admin, language)
            VALUES (:id, :name, :email, FALSE, FALSE, 'fi')
        """), {"id": uid, "name": name, "email": email})


def add_survey(survey_id, group_amount, stages):
    if stages > 0:
        min_choices_per_stage = {
            f"stage_{i}": 1 for i in range(1, stages + 1)
        }
    else:
        min_choices_per_stage = None
    
    db.session.execute(text("""
        INSERT INTO surveys (
            id, surveyname, min_choices, closed, results_saved,
            survey_description, time_end, allowed_denied_choices,
            allow_search_visibility, allow_absences, deleted, min_choices_per_stage
        ) VALUES (
            :id, 'Test Survey', :min_choices, FALSE, FALSE,
            'Autogenerated test survey', NOW() + INTERVAL '30 days',
            0, TRUE, TRUE, FALSE, :min_choices_per_stage
        )
    """), {"id": survey_id, "min_choices": group_amount, "min_choices_per_stage": json.dumps(min_choices_per_stage) if stages > 0 else None})


def add_groups_and_stages(survey_id, group_amount, stages=0):
    db.session.execute(text("DELETE FROM survey_choices WHERE survey_id = :sid"), {"sid": survey_id})
    db.session.execute(text("DELETE FROM survey_stages WHERE survey_id = :sid"), {"sid": survey_id})

    choice_ids = list(range(1, group_amount + 1))

    for cid in choice_ids:
        db.session.execute(text("""
            INSERT INTO survey_choices (
                id, survey_id, name, max_spaces, deleted,
                min_size, participation_limit, mandatory
            ) VALUES (
                :id, :sid, :name, 100, FALSE,
                1, 0, FALSE
            )
        """), {"id": cid, "sid": survey_id, "name": f"Ryhm√§ {cid}"})

    if stages == 0:
        return [choice_ids]

    stage_lists = [[] for _ in range(stages)]
    for i, cid in enumerate(choice_ids):
        stage_lists[i % stages].append(cid)
    for idx, clist in enumerate(stage_lists, start=1):
        stage_name = f"stage_{idx}"
        for _, cid in enumerate(clist, start=1):
            db.session.execute(text("""
                INSERT INTO survey_stages (survey_id, choice_id, stage, order_number)
                VALUES (:sid, :cid, :stage, :ord)
            """), {"sid": survey_id, "cid": cid, "stage": stage_name, "ord": idx})

    return stage_lists

def add_rankings(survey_id, stage_lists, students, multistage=False):
    db.session.execute(text("DELETE FROM user_survey_rankings WHERE survey_id = :sid"), {"sid": survey_id})

    for user_id in range(1, students + 1):
        for idx, choice_list in enumerate(stage_lists, start=1):
            stage = f"stage_{idx}" if multistage else None

            ranking = ",".join(str(x) for x in random.sample(choice_list, len(choice_list)))

            db.session.execute(text("""
                INSERT INTO user_survey_rankings (
                    user_id, survey_id, ranking,
                    rejections, reason, deleted, stage, not_available
                ) VALUES (
                    :uid, :sid, :ranking,
                    '', '', FALSE, :stage, :na
                )
            """), {
                "uid": user_id,
                "sid": survey_id,
                "ranking": ranking,
                "stage": stage,
                "na": random.random() < 0.05 if multistage else None  # 5% unavailable
            })


def fill_database(groups, students, stages=3, multistage=False):
    clear_database()

    survey_id = generate_unique_id(10)

    if not multistage:
        stages = 0

    with db.session.begin():
        try:
            add_survey(survey_id, groups, stages)
            add_teacher(survey_id)
            add_students(students)
            stage_lists = add_groups_and_stages(survey_id, groups, stages)
            add_rankings(survey_id, stage_lists, students, multistage)
        except Exception as e:
            print(e)

    print("Database filled successfully")
    print(f" survey_id = {survey_id}")
    print(f" groups = {groups}")
    print(f" students = {students}")
    print(f" stages = {stages}")

    return survey_id
